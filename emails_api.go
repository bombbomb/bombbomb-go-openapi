/*
 * BombBomb
 *
 * We make it easy to build relationships using simple videos.
 *
 * API version: 2.0.831
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package bombbomb

import (
	"io/ioutil"
	"net/url"
	"net/http"
	"strings"
	"golang.org/x/net/context"
	"fmt"
)

// Linger please
var (
	_ context.Context
)

type EmailsApiService service


/* EmailsApiService Create an Email with Printing Press
 Prints an email using the template id and content to the users account.If a video id is included, it will replace any video placeholders with that video.
 * @param ctx context.Context for authentication, logging, tracing, etc.
 @param templateId The template id to be printed.
 @param content The content of the email.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "emailId" (string) The email id to be printed to.
     @param "videoId" (string) A video to replace video place holders with.
     @param "subjectLine" (string) The subject line to be printed.
 @return */
func (a *EmailsApiService) CreatePrintingPressEmail(ctx context.Context, templateId string, content string, localVarOptionals map[string]interface{}) ( *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/emails/print"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if err := typeCheckParameter(localVarOptionals["emailId"], "string", "emailId"); err != nil {
		return nil, err
	}
	if err := typeCheckParameter(localVarOptionals["videoId"], "string", "videoId"); err != nil {
		return nil, err
	}
	if err := typeCheckParameter(localVarOptionals["subjectLine"], "string", "subjectLine"); err != nil {
		return nil, err
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/x-www-form-urlencoded",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("templateId", parameterToString(templateId, ""))
	localVarFormParams.Add("content", parameterToString(content, ""))
	if localVarTempParam, localVarOk := localVarOptionals["emailId"].(string); localVarOk {
		localVarFormParams.Add("emailId", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["videoId"].(string); localVarOk {
		localVarFormParams.Add("videoId", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["subjectLine"].(string); localVarOk {
		localVarFormParams.Add("subjectLine", parameterToString(localVarTempParam, ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	return localVarHttpResponse, err
}

/* EmailsApiService Get all user templates
 Get all templates accessible to the current user
 * @param ctx context.Context for authentication, logging, tracing, etc.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "quickSendOnly" (bool) Whether to return only quick send templates.
 @return */
func (a *EmailsApiService) GetAllTemplatesForCurrentUser(ctx context.Context, localVarOptionals map[string]interface{}) ( *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/emails/templates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if err := typeCheckParameter(localVarOptionals["quickSendOnly"], "bool", "quickSendOnly"); err != nil {
		return nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["quickSendOnly"].(bool); localVarOk {
		localVarQueryParams.Add("quickSendOnly", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/x-www-form-urlencoded",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	return localVarHttpResponse, err
}

/* EmailsApiService Get Email Tracking
 Get Tracking data for all sends of an Email
 * @param ctx context.Context for authentication, logging, tracing, etc.
 @param emailId ID of the email
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "jobId" (string) ID of the Job (or null for all jobs)
 @return */
func (a *EmailsApiService) GetEmailTracking(ctx context.Context, emailId string, localVarOptionals map[string]interface{}) ( *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/emails/{emailId}/tracking"
	localVarPath = strings.Replace(localVarPath, "{"+"emailId"+"}", fmt.Sprintf("%v", emailId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if err := typeCheckParameter(localVarOptionals["jobId"], "string", "jobId"); err != nil {
		return nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["jobId"].(string); localVarOk {
		localVarQueryParams.Add("jobId", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/x-www-form-urlencoded",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	return localVarHttpResponse, err
}

/* EmailsApiService Get Email Tracking Interactions
 Get Contact detail interactions for an Email
 * @param ctx context.Context for authentication, logging, tracing, etc.
 @param emailId ID of the email
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "jobId" (string) ID of the Job (or null for all jobs)
     @param "interactionType" (string) Interaction type to order and filter by
     @param "searchTerm" (string) Search term to filer by
 @return */
func (a *EmailsApiService) GetEmailTrackingInteractions(ctx context.Context, emailId string, localVarOptionals map[string]interface{}) ( *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/emails/{emailId}/tracking/interactions"
	localVarPath = strings.Replace(localVarPath, "{"+"emailId"+"}", fmt.Sprintf("%v", emailId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if err := typeCheckParameter(localVarOptionals["jobId"], "string", "jobId"); err != nil {
		return nil, err
	}
	if err := typeCheckParameter(localVarOptionals["interactionType"], "string", "interactionType"); err != nil {
		return nil, err
	}
	if err := typeCheckParameter(localVarOptionals["searchTerm"], "string", "searchTerm"); err != nil {
		return nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["jobId"].(string); localVarOk {
		localVarQueryParams.Add("jobId", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["interactionType"].(string); localVarOk {
		localVarQueryParams.Add("interactionType", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["searchTerm"].(string); localVarOk {
		localVarQueryParams.Add("searchTerm", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/x-www-form-urlencoded",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	return localVarHttpResponse, err
}

/* EmailsApiService Get Hourly Email Tracking
 Get Tracking data for an Email,             broken down by the hour and filterable by an Interaction type
 * @param ctx context.Context for authentication, logging, tracing, etc.
 @param emailId ID of the email
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "jobId" (string) ID of the Job (or null for all jobs)
     @param "interactionType" (string) Interaction type to filter by
 @return */
func (a *EmailsApiService) GetHourlyEmailTracking(ctx context.Context, emailId string, localVarOptionals map[string]interface{}) ( *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/emails/{emailId}/tracking/hourly"
	localVarPath = strings.Replace(localVarPath, "{"+"emailId"+"}", fmt.Sprintf("%v", emailId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if err := typeCheckParameter(localVarOptionals["jobId"], "string", "jobId"); err != nil {
		return nil, err
	}
	if err := typeCheckParameter(localVarOptionals["interactionType"], "string", "interactionType"); err != nil {
		return nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["jobId"].(string); localVarOk {
		localVarQueryParams.Add("jobId", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["interactionType"].(string); localVarOk {
		localVarQueryParams.Add("interactionType", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/x-www-form-urlencoded",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	return localVarHttpResponse, err
}

/* EmailsApiService Get livefire feed data
 Get the user data for the live fire feed emails
 * @param ctx context.Context for authentication, logging, tracing, etc.
 @return */
func (a *EmailsApiService) GetLiveFireData(ctx context.Context) ( *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/emails/livefire"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/x-www-form-urlencoded",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	return localVarHttpResponse, err
}

/* EmailsApiService Get all quicksend templates
 Get all quicksend templates accessible to the user.
 * @param ctx context.Context for authentication, logging, tracing, etc.
 @return */
func (a *EmailsApiService) GetQuickSendTemplates(ctx context.Context) ( *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/emails/quicksend/templates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/x-www-form-urlencoded",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	return localVarHttpResponse, err
}

/* EmailsApiService Get the HTML for a given template
 Get the HTML for a given template, with or without rendered variables
 * @param ctx context.Context for authentication, logging, tracing, etc.
 @param templateId The id of the template.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "renderVariables" (string) Whether to render profile variables in the returned HTML.
 @return */
func (a *EmailsApiService) GetTemplateHtmlForTemplateId(ctx context.Context, templateId string, localVarOptionals map[string]interface{}) ( *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/emails/templates/{templateId}/html"
	localVarPath = strings.Replace(localVarPath, "{"+"templateId"+"}", fmt.Sprintf("%v", templateId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if err := typeCheckParameter(localVarOptionals["renderVariables"], "string", "renderVariables"); err != nil {
		return nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["renderVariables"].(string); localVarOk {
		localVarQueryParams.Add("renderVariables", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/x-www-form-urlencoded",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	return localVarHttpResponse, err
}

/* EmailsApiService Get quicksend data
 Get the user data for quicksender, including templates and lists.
 * @param ctx context.Context for authentication, logging, tracing, etc.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "message" (string) A message for the video content.
     @param "subject" (string) A subject for the video content.
     @param "videoId" (string) A video ID.
     @param "templateId" (string) A template ID.
     @param "commaDelimEmails" (string) Comma delimited emails
 @return */
func (a *EmailsApiService) GetVideoQuickSenderData(ctx context.Context, localVarOptionals map[string]interface{}) ( *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/emails/quicksend"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if err := typeCheckParameter(localVarOptionals["message"], "string", "message"); err != nil {
		return nil, err
	}
	if err := typeCheckParameter(localVarOptionals["subject"], "string", "subject"); err != nil {
		return nil, err
	}
	if err := typeCheckParameter(localVarOptionals["videoId"], "string", "videoId"); err != nil {
		return nil, err
	}
	if err := typeCheckParameter(localVarOptionals["templateId"], "string", "templateId"); err != nil {
		return nil, err
	}
	if err := typeCheckParameter(localVarOptionals["commaDelimEmails"], "string", "commaDelimEmails"); err != nil {
		return nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["message"].(string); localVarOk {
		localVarQueryParams.Add("message", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["subject"].(string); localVarOk {
		localVarQueryParams.Add("subject", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["videoId"].(string); localVarOk {
		localVarQueryParams.Add("videoId", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["templateId"].(string); localVarOk {
		localVarQueryParams.Add("templateId", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["commaDelimEmails"].(string); localVarOk {
		localVarQueryParams.Add("commaDelimEmails", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/x-www-form-urlencoded",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	return localVarHttpResponse, err
}

/* EmailsApiService Save quicksender settings
 Save the quicksender notification and default template settings
 * @param ctx context.Context for authentication, logging, tracing, etc.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "alertOnPlay" (string) A preference setting for whether or not to notify user on quicksend email video plays.
     @param "alertOnOpen" (string) A preference setting for whether or not to notify user on quicksend email opens.
     @param "templateId" (string) Id of a template to use for this send. A null value means use the default for this user.
 @return */
func (a *EmailsApiService) SaveQuickSenderSettings(ctx context.Context, localVarOptionals map[string]interface{}) ( *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/emails/quicksend/settings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if err := typeCheckParameter(localVarOptionals["alertOnPlay"], "string", "alertOnPlay"); err != nil {
		return nil, err
	}
	if err := typeCheckParameter(localVarOptionals["alertOnOpen"], "string", "alertOnOpen"); err != nil {
		return nil, err
	}
	if err := typeCheckParameter(localVarOptionals["templateId"], "string", "templateId"); err != nil {
		return nil, err
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/x-www-form-urlencoded",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarTempParam, localVarOk := localVarOptionals["alertOnPlay"].(string); localVarOk {
		localVarFormParams.Add("alertOnPlay", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["alertOnOpen"].(string); localVarOk {
		localVarFormParams.Add("alertOnOpen", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["templateId"].(string); localVarOk {
		localVarFormParams.Add("templateId", parameterToString(localVarTempParam, ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	return localVarHttpResponse, err
}

/* EmailsApiService Send a quicksend email
 Send a quicksend video email to the list or users provided.
 * @param ctx context.Context for authentication, logging, tracing, etc.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "videoId" (string) A guid id for the video.
     @param "emailAddresses" (string) A semi-colon separated list of email addresses to send to.
     @param "subject" (string) Subject line for the email.
     @param "message" (string) Message for the body of the email.
     @param "listIds" (string) An array of list ids
     @param "scheduledSendTimestamp" (int32) When to schedule the send (seconds since epoch). null value means send immediately.
     @param "extendedProperties" (string) Bool value that when checked will send back both emailId as well as extra properties
     @param "templateId" (string) Id of a template to use for this send. A null value means use the default for this user.
     @param "stripHTML" (string) remove HTML elements
 @return */
func (a *EmailsApiService) VideoQuickSender(ctx context.Context, localVarOptionals map[string]interface{}) ( *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/emails/quicksend"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if err := typeCheckParameter(localVarOptionals["videoId"], "string", "videoId"); err != nil {
		return nil, err
	}
	if err := typeCheckParameter(localVarOptionals["emailAddresses"], "string", "emailAddresses"); err != nil {
		return nil, err
	}
	if err := typeCheckParameter(localVarOptionals["subject"], "string", "subject"); err != nil {
		return nil, err
	}
	if err := typeCheckParameter(localVarOptionals["message"], "string", "message"); err != nil {
		return nil, err
	}
	if err := typeCheckParameter(localVarOptionals["listIds"], "string", "listIds"); err != nil {
		return nil, err
	}
	if err := typeCheckParameter(localVarOptionals["scheduledSendTimestamp"], "int32", "scheduledSendTimestamp"); err != nil {
		return nil, err
	}
	if err := typeCheckParameter(localVarOptionals["extendedProperties"], "string", "extendedProperties"); err != nil {
		return nil, err
	}
	if err := typeCheckParameter(localVarOptionals["templateId"], "string", "templateId"); err != nil {
		return nil, err
	}
	if err := typeCheckParameter(localVarOptionals["stripHTML"], "string", "stripHTML"); err != nil {
		return nil, err
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/x-www-form-urlencoded",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarTempParam, localVarOk := localVarOptionals["videoId"].(string); localVarOk {
		localVarFormParams.Add("videoId", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["emailAddresses"].(string); localVarOk {
		localVarFormParams.Add("emailAddresses", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["subject"].(string); localVarOk {
		localVarFormParams.Add("subject", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["message"].(string); localVarOk {
		localVarFormParams.Add("message", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["listIds"].(string); localVarOk {
		localVarFormParams.Add("listIds", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["scheduledSendTimestamp"].(int32); localVarOk {
		localVarFormParams.Add("scheduledSendTimestamp", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["extendedProperties"].(string); localVarOk {
		localVarFormParams.Add("extendedProperties", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["templateId"].(string); localVarOk {
		localVarFormParams.Add("templateId", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["stripHTML"].(string); localVarOk {
		localVarFormParams.Add("stripHTML", parameterToString(localVarTempParam, ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	return localVarHttpResponse, err
}

